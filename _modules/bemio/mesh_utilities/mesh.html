

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>bemio.mesh_utilities.mesh &mdash; bemio v1.0a0 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="bemio v1.0a0 documentation" href="../../../index.html"/>
        <link rel="up" title="Module code" href="../../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../../index.html" class="icon icon-home"> bemio
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../installing.html">Downloading and Installing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../installing.html#downloading-bemio">Downloading bemio</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installing.html#dependencies">Dependencies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installing.html#installing-quick-start-for-python-beginners">Installing: Quick Start for Python Beginners</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installing.html#installing-for-experienced-python-users">Installing: For Experienced Python Users</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../installing.html#installing-vtk-with-python-bindings">Installing VTK with Python Bindings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../installing.html#osx">OSX</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../installing.html#method-1-simple">Method 1: Simple</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../installing.html#method-2-complex">Method 2: Complex</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../installing.html#pre-installation-tasks">Pre-Installation Tasks</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../installing.html#linux">Linux</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../installing.html#windows">Windows</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../api.html">Using the bemio API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#loading-data">Loading Data</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#data-objects">Data Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#calculating-impulse-response-functions-and-sate-space-coefficients">Calculating Impulse Response Functions and Sate Space Coefficients</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../api.html#writing-the-data-to-the-standard-bemio-format">Writing the Data to the Standard bemio Format</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials.html#tutorial-data-files">Tutorial Data Files</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../tutorials.html#available-tutorials">Available Tutorials</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../wamit.html">WAMIT</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../wamit.html#viewing-the-shdf-file">Viewing the SHDF File</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../wamit.html#references">References</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../nemoh.html">NEMOH</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../nemoh.html#load-the-nemoh-module-from-bemio-io">Load the nemoh module from bemio.io</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../nemoh.html#load-the-bem-data-object-from-bemio-data-structures">Load the bem data object from bemio.data_structures</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../nemoh.html#read-the-nemoh-simulation-data-from-the">Read the Nemoh simulation data from the</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../nemoh.html#read-the-hydrostatic-and-ih-files">Read the hydrostatic and IH files</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../nemoh.html#calculate-the-irf-and-state-space-coefficients">Calculate the IRF and state space coefficients</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../nemoh.html#plot-the-surge-and-heave-components-of-added-mass-and-radiation-damping-for-body-0">Plot the surge and heave components of added mass and radiation damping for body 0</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../nemoh.html#write-the-data-to-the-bemio-data-file-format-for-use-with-wec-sim">Write the data to the bemio data file format for use with WEC-Sim</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../aqwa.html">AQWA</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../module_doc.html">bemio module documentation</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../module_doc.html#bemio-io">bemio.io</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../module_doc.html#module-bemio.io.wamit">wamit</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../module_doc.html#module-bemio.io.aqwa">aqwa</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../module_doc.html#module-bemio.io.nemoh">nemoh</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../module_doc.html#module-bemio.io.output">output</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../module_doc.html#bemio-data-structures">bemio.data_structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../module_doc.html#module-bemio.data_structures.bem">bem</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../module_doc.html#module-bemio.data_structures.wave_excitation">wave_excitation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../module_doc.html#bemio-mesh-utilities">bemio.mesh_utilities</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../module_doc.html#module-bemio.mesh_utilities.mesh">mesh</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../license.html">License</a></li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">bemio</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      
    <li>bemio.mesh_utilities.mesh</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <h1>Source code for bemio.mesh_utilities.mesh</h1><div class="highlight"><pre>
# Copyright 2014 the National Renewable Energy Laboratory
#
# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
&quot;&quot;&quot;
This module serves provides utilities to work with the following mesh types:
    - WAMTI
    - Nemoh
    - VTK Polydata
    - STL files

The functionality provided includes:
    - Ability to read mesh the mesh formats listed above
    - Ability to convert between mesh formats listed above
    - Utilities to calculate volume, surface area, linear spring stiffness, and other related mesh parameters.

&quot;&quot;&quot;
import numpy as np

import imp

import os

from sys import platform as _platform

from copy import copy

from platform import system as _system

try:

    import vtk
    from vtk.util.numpy_support import vtk_to_numpy


except:

    print &#39;The VTK Python module is required for a significant amnount of functionality in this module. Many functions will not be available for use.&#39;



class VTK_Exception(Exception):
    pass

<div class="viewcode-block" id="PanelMesh"><a class="viewcode-back" href="../../../module_doc.html#bemio.mesh_utilities.mesh.PanelMesh">[docs]</a>class PanelMesh(object):
    &#39;&#39;&#39; Class to store mesh data. All mesh data is currently read and stored as quad elements. Tri elements are supported, but are stored as quad elements with a repeated point.

    Parameters:
        file_name : str
            Name of mesh file to read. Currently WAMIT (.gdf), Stereolithography
            (.stl), VTK PolyDATA (.vtp), and NEMOH (.dat) mesh formats are
            supported

    Attribuites:
        files : dictionary
            Dictionary containg input and output file names
        orig_type : str
            Mesh type of input file
        points : list
            List of points that define the mesh. `points[n] = [x coord, y coord, z coord]`.
        faces : list
            List of points that define connectivity for each face. `face[n] = [point 1 index
            , point 2 index, point 3 index, point 4 index]`, where &#39;point 1-4&#39;
            are integres that correspond to the point index in the `points`
            attribuite.
        center_of_gravity : np.array
            Center of gravity of floating body
        center_of_buoyancy : np.array
            Center of buoyancy
        volume_vtk : np.array
            Mesh volume determined using VTK
        volume_x, y, and z : np.array
            Mesh volume determined using internal bemio calculations
        surface_area_vtk : float
            Surface area determined using VTK
        surface_area : float
            Surface area determined using internal bemio calculations
        normals : np.array
            Cell normals. This arrays is size `[faces.shape[0], 3]`.
            `normals[n] = [x, y, z]` is a vector that defines the normal vector
            for face `n`
        cell_surface_area : np.array
            Cell survace area. This array is size `[faces.shape[0], 3]`.
            `cell_surface_area[n]` is the surface aras of face[n].
        centroid : np.array
            Cell centroid. This array is size `[faces.shape[0], 3]`.
            `cell_surface_area[n]` is centroid of face[n].
        hydrostatic_stiffness : np.array
            The linear hydrostatic stiffness matrix of the mesh assuming the
            water surface is at z=0
        bounds : dictionary
            The bounds of the mesh. `bounds[&#39;min&#39;]` and `bounds[&#39;max&#39;]` are the
            minimum and maximum mesh dimensions, respectively
    &#39;&#39;&#39;
    def __init__(self,file_name):

        self.files = {}
        self.files[&#39;input_file&#39;] = file_name

        self.orig_type = None
        self.points = []
        self.faces = []
        self.center_of_gravity = np.array([0., 0., 0.])
        self._center_of_buoyancy = None
        self._volume_vtk = None
        self._volume_x = None
        self._volume_y = None
        self._volume_z = None
        self._surface_area = None
        self._surface_area_vtk = None
        self._normals = None
        self._cell_surface_area = None
        self._centroid = None
        self._hydrostatic_stiffness = None
        self._bounds = None

        self.zero_tol = -1.e-3

        try:

            imp.find_module(&#39;vtk&#39;)
            self.VTK_installed = True

        except :

            self.VTK_installed = False

        if os.path.isfile(file_name) is False:

            raise Exception(&#39;The file &#39; + file_name + &#39; does not exist&#39;)

    def __repr__(self):
        out_string = &#39;Object type: bemio.mesh_utilities.mesh.PanelMesh&#39; + \
        &#39;\nFile name: &#39; + str(self.files[&#39;input_file&#39;]) + \
        &#39;\nNumber of points: &#39; + str(self.points.shape[0]) + \
        &#39;\nNumber of faces: &#39; + str(self.faces.shape[0]) + \
        &#39;\nOriginal mesh type: &#39; + str(self.orig_type) + \
        &#39;\nMesh bounds:&#39; + \
        &#39;\n\tMax: &#39; + str(self.bounds[&#39;max&#39;]) + \
        &#39;\n\tMin: &#39; + str(self.bounds[&#39;min&#39;]) + \
        &#39;\nCenter of mass: &#39; + str(self.center_of_gravity) + \
        &#39;\nCenter of buoyancy: &#39; + str(self.center_of_buoyancy) + \
        &#39;\nMesh volume [volume_x, volume_y, volume_z]: [&#39; + str(self.volume_x) + &#39;, &#39; + str(self.volume_y) + &#39;, &#39; + str(self.volume_z) + &#39;]&#39; + \
        &#39;\nMesh surface area: &#39; + str(self.surface_area) + \
        &#39;\nHydrostatic stiffness: &#39; + \
        &#39;\n\tC[3,3], C[3,4], C[3,5]: &#39;  +  str(self.hydrostatic_stiffness[2,2]) + &#39;, &#39; + str(self.hydrostatic_stiffness[2,3]) + &#39;, &#39; + str(self.hydrostatic_stiffness[2,4]) + \
        &#39;\n\tC[4,4], C[4,5], C[4,6]: &#39;  +  str(self.hydrostatic_stiffness[3,3]) + &#39;, &#39; + str(self.hydrostatic_stiffness[3,4]) + &#39;, &#39; + str(self.hydrostatic_stiffness[3,5]) + \
        &#39;\n\tC[5,5], C[5,6]:         &#39;  +  str(self.hydrostatic_stiffness[4,4]) + &#39;, &#39; + str(self.hydrostatic_stiffness[4,5])

        return out_string

    @ property
    def bounds(self, ):
        if self._bounds is None:
            self._bounds = {}
            self._bounds[&#39;max&#39;] = self.points.max(axis=0)
            self._bounds[&#39;min&#39;] = self.points.min(axis=0)

        return self._bounds

    @property
    def hydrostatic_stiffness(self, ):
        &#39;&#39;&#39;Getter for the `hydrostatic_stiffness` variable.

        Calculated as defined in Section 3.1 of the WAMIT v7.0 users manual.
        &#39;&#39;&#39;
        if self._hydrostatic_stiffness is None:

            self._hydrostatic_stiffness = np.zeros([6,6])
            for face_n,face in enumerate(self.faces):

                if self.points[face[0]][2] &lt;= self.zero_tol or \
                self.points[face[1]][2] &lt;= self.zero_tol or \
                self.points[face[2]][2] &lt;= self.zero_tol or \
                self.points[face[3]][2] &lt;= self.zero_tol:
                    self._hydrostatic_stiffness[2,2] += -self.normals[face_n][2] * self.cell_surface_area[face_n]
                    self._hydrostatic_stiffness[2,3] += -self.centroid[face_n][1] * self.normals[face_n][2] * self.cell_surface_area[face_n]
                    self._hydrostatic_stiffness[2,4] += self.centroid[face_n][0] * self.normals[face_n][2] * self.cell_surface_area[face_n]
                    self._hydrostatic_stiffness[3,3] += -self.centroid[face_n][1]**2 * self.normals[face_n][2] * self.cell_surface_area[face_n]
                    self._hydrostatic_stiffness[3,4] += self.centroid[face_n][0] * self.centroid[face_n][1] * self.normals[face_n][2] * self.cell_surface_area[face_n]
                    self._hydrostatic_stiffness[4,4] += -self.centroid[face_n][0]**2 * self.normals[face_n][2] * self.cell_surface_area[face_n]

            self._hydrostatic_stiffness[3,3] += self.volume_x * self.center_of_buoyancy[2] - self.volume_x * self.center_of_gravity[2]
            self._hydrostatic_stiffness[3,5] += -self.volume_x * self.center_of_buoyancy[0] + self.volume_x * self.center_of_gravity[0]
            self._hydrostatic_stiffness[4,4] += self.volume_x * self.center_of_buoyancy[2] - self.volume_x * self.center_of_gravity[2]
            self._hydrostatic_stiffness[4,5] += -self.volume_x * self.center_of_buoyancy[1] + self.volume_x * self.center_of_gravity[1]

            print &#39;Calculated hydorstatic stiffness&#39;

        return self._hydrostatic_stiffness

    @property
    def center_of_buoyancy(self, ):
        &#39;&#39;&#39;Getter for the `center_of_buoyancy` variable.

        Calculated as defined in Section 3.1 of the WAMIT v7.0 users manual.
        &#39;&#39;&#39;
        if self._center_of_buoyancy is None:
            x_b = 0.
            y_b = 0.
            z_b = 0.
            self._center_of_buoyancy = 0.

            for face_n,face in enumerate(self.faces):
                if self.points[face[0]][2] &lt;= self.zero_tol or \
                self.points[face[1]][2] &lt;= self.zero_tol or \
                self.points[face[2]][2] &lt;= self.zero_tol or \
                self.points[face[3]][2] &lt;= self.zero_tol:
                    x_b += self.normals[face_n][0]*self.centroid[face_n][0]**2*self.cell_surface_area[face_n]
                    y_b += self.normals[face_n][1]*self.centroid[face_n][1]**2*self.cell_surface_area[face_n]
                    z_b += self.normals[face_n][2]*self.centroid[face_n][2]**2*self.cell_surface_area[face_n]
            self._center_of_buoyancy = 1./(2.*self.volume_x )*np.array([x_b, y_b, z_b])

            print &#39;Calculated the center of buoyancy&#39;

        return self._center_of_buoyancy


    @property
    def normals(self, ):
        if self._normals is None:
            self._normals = {}
            for face_n in xrange(self.faces.shape[0]):
                a = self.points[self.faces[face_n][1]] - self.points[self.faces[face_n][0]]
                b = self.points[self.faces[face_n][2]] - self.points[self.faces[face_n][1]]
                self._normals[face_n] = np.cross(a,b)

                if self._normals[face_n][0] == 0. and  self._normals[face_n][1] == 0. and self._normals[face_n][2] == 0.:
                    a = self.points[self.faces[face_n][2]] - self.points[self.faces[face_n][1]]
                    b = self.points[self.faces[face_n][3]] - self.points[self.faces[face_n][2]]
                    self._normals[face_n] = np.cross(a,b)

                if self._normals[face_n][0] == 0. and  self._normals[face_n][1] == 0. and self._normals[face_n][2] == 0.:
                    a = self.points[self.faces[face_n][2]] - self.points[self.faces[face_n][0]]
                    b = self.points[self.faces[face_n][3]] - self.points[self.faces[face_n][2]]
                    self._normals[face_n] = np.cross(a,b)

                self._normals[face_n] /= np.linalg.norm(self._normals[face_n])

            print &#39;Calculated mesh cell normals&#39;

        return self._normals


    @property
    def cell_surface_area(self):
        &#39;&#39;&#39;Getter for `cell_surface_area`

        Calculated
        &#39;&#39;&#39;
        if self._cell_surface_area is None:
            self._cell_surface_area = {}
            for face_n in xrange(self.faces.shape[0]):
                a = self.points[self.faces[face_n][1]] - self.points[self.faces[face_n][0]]
                b = self.points[self.faces[face_n][2]] - self.points[self.faces[face_n][1]]
                c = self.points[self.faces[face_n][3]] - self.points[self.faces[face_n][2]]
                d = self.points[self.faces[face_n][0]] - self.points[self.faces[face_n][3]]
                self._cell_surface_area[face_n] = 1./2. * ( np.linalg.norm(np.cross(a,b)) + np.linalg.norm(np.cross(c,d)) )

            print &#39;Calculated surface cell area&#39;

        return self._cell_surface_area

    @property
    def surface_area(self):
        if self._surface_area is None:

            self._surface_area = sum(self.cell_surface_area.values())

            print &#39;Calculated surface area&#39;

        return self._surface_area

    @property
    def volume_vtk(self):
        if self.VTK_installed is False:
            raise VTK_Exception(&#39;VTK must be installed to access the volume_vtk property&#39;)

        if self._volume_vtk is None:
            tri_converter = vtk.vtkTriangleFilter()
            tri_converter.SetInputDataObject(self.vtp_mesh)
            tri_converter.Update()
            tri_mesh = tri_converter.GetOutput()
            mass_props = vtk.vtkMassProperties()
            mass_props.SetInputDataObject(tri_mesh)
            self._volume_vtk = mass_props.GetVolume()

            print &#39;Calculated mesh volume using VTK library&#39;

        return self._volume_vtk

    @property
    def centroid(self):

        if self._centroid is None:
            self._centroid = {}

            for face_n,face in enumerate(self.faces):
                points = [self.points[face[0]],
                          self.points[face[1]],
                          self.points[face[2]],
                          self.points[face[3]]]

                points = map(np.asarray, set(map(tuple, points))) # This removes duplicate points... somehow
                self._centroid[face_n] = np.mean(points,axis=0)

        return self._centroid


    @property
    def volume_x(self):
        if self._volume_x is None:
            self._calc_component_vol()
        return self._volume_x


    @property
    def volume_y(self):
        if self._volume_y is None:
            self._calc_component_vol()
        return self._volume_y


    @property
    def volume_z(self):
        if self._volume_z is None:
            self._calc_component_vol()
        return self._volume_z


    @property
    def surface_area_vtk(self):
        if self.VTK_installed is False:
            raise VTK_Exception(&#39;VTK must be installed to access the surface_area_vtk property&#39;)
        if self._surface_area_vtk is None:
            tri_converter = vtk.vtkTriangleFilter()
            tri_converter.SetInputDataObject(self.vtp_mesh)
            tri_converter.Update()
            tri_mesh = tri_converter.GetOutput()
            mass_props = vtk.vtkMassProperties()
            mass_props.SetInputDataObject(tri_mesh)
            self._surface_area_vtk = mass_props.GetSurfaceArea()

            print &#39;Calculated mesh surface area using VTK Python bindings&#39;

        return self._surface_area_vtk


<div class="viewcode-block" id="PanelMesh.write"><a class="viewcode-back" href="../../../module_doc.html#bemio.mesh_utilities.mesh.PanelMesh.write">[docs]</a>    def write(self,mesh_format=&#39;VTP&#39;):
        &#39;&#39;&#39;Function to write NEMOH, WAMIT, or VTK PolyData formats.

        Parameters:
            mesh_format : string {&#39;VTP&#39;, &#39;WAMIT&#39;, &#39;NEMOH&#39;}
                Variable that specifies the mesh format to write.

        Examples:
            This example assumes that a mesh has been read by bemio and mesh
            data is contained in a `PanelMesh` object called `mesh`

            Here is how a WAMIT mesh would be written
            &gt;&gt;&gt; mesh.write(mesh_format=&#39;WAMTI&#39;)
        &#39;&#39;&#39;
        if mesh_format == &#39;VTK&#39; or mesh_format == &#39;VTP&#39;:
            self._write_vtp()

        if mesh_format == &#39;WAMIT&#39; or mesh_format == &#39;GDF&#39;:
            self._write_gdf()

        if mesh_format == &#39;NEMOH&#39;:
            self._write_nemoh()

</div>
<div class="viewcode-block" id="PanelMesh.calculate_center_of_gravity_vtk"><a class="viewcode-back" href="../../../module_doc.html#bemio.mesh_utilities.mesh.PanelMesh.calculate_center_of_gravity_vtk">[docs]</a>    def calculate_center_of_gravity_vtk(self, ):
        &#39;&#39;&#39;Function to calculate the center of gravity

        .. Note::
            The VTK Pytnon bindings must be installed to use this function

        Examples:
            This example assumes that a mesh has been read by bemio and mesh data is contained in a `PanelMesh` object called `mesh`

            &gt;&gt;&gt; mesh.calculate_center_of_gravity_vtk()
        &#39;&#39;&#39;
        if self.VTK_installed is False:
            raise VTK_Exception(&#39;VTK must be installed to access the calculate_center_of_gravity_vtk function&#39;)

        com = vtk.vtkCenterOfMass()
        if vtk.VTK_MAJOR_VERSION &gt;= 6:
            com.SetInputData(self.vtp_mesh)
        else:
            com.SetInput(self.vtp_mesh)
        com.Update()
        self.center_of_gravity = com.GetCenter()

        print &#39;Calculated center of gravity assuming uniform material density&#39;

    # def cut(self,plane=2,value=0.0,direction=1):</div>
    &#39;&#39;&#39;This function is not currently working 100%
    &#39;&#39;&#39;
    #     self.collapse(plane,value,direction)
    #
    #     tempFaces = []
    #     count = 0
    #
    #     for i in xrange(self.faces.shape[0]):
    #
    #        delete_face = 0
    #
    #        for j in xrange(4):
    #
    #            p = self.faces[i][j]
    #            z = float(self.cords[int(p)][2])
    #
    #            if z == 0.:
    #                delete_face += 1
    #
    #        if delete_face != 4:
    #            tempFaces.append(self.faces[i])
    #            count  += 1
    #
    #     print &#39;removed &#39; + str(count) + &#39; surface faces&#39;
    #     self.faces = tempFaces
    #     self.faces.shape[0] = self.faces.shape[0]

<div class="viewcode-block" id="PanelMesh.view"><a class="viewcode-back" href="../../../module_doc.html#bemio.mesh_utilities.mesh.PanelMesh.view">[docs]</a>    def view(self, color=[0.5,1,0.5], opacity=1.0, save_png=False, camera_pos=[50,50,50], interact=True):
        &#39;&#39;&#39;Function to view the mesh using the VTK library

        Parameters:
            color : list, optional
                VTK color specification for the mesh
            opackty : float, optional
                VTK opacity for the mesh. Must be between 0. and 1.
            save_png : bool
                Boolean operater that determines if a .png image of the mesh is saved.
            interact : bool, optional
                Boolean operater that determines if the user can interact with the geometry (e.g. zoom and rotate) after it is displayed
            camera_pos : list, optional
                Camera position

        Examples:
            This example assumes that a mesh has been read by bemio and mesh data is contained in a `PanelMesh` object called `mesh`

            &gt;&gt;&gt; mesh.view()

            The mesh view window must be closed in order to return command to the Python shell
        &#39;&#39;&#39;
        if self.VTK_installed is False:
            raise VTK_Exception(&#39;VTK must be installed to use the view function&#39;)

        # Create a mapper and load VTP data into the mapper
        mapper=vtk.vtkPolyDataMapper()
        if vtk.VTK_MAJOR_VERSION &gt;= 6:
            mapper.SetInputData(self.vtp_mesh)
        else:
            mapper.SetInput(self.vtp_mesh)

        # Create an actor that contains the data in the mapper
        actor=vtk.vtkActor()
        actor.GetProperty().SetColor(color)
        actor.GetProperty().SetOpacity(opacity)
        actor.SetMapper(mapper)
        actor.GetProperty().EdgeVisibilityOn()

        # Camera
        camera = vtk.vtkCamera();
        camera.SetPosition(camera_pos)
        camera.SetFocalPoint(0, 0, 0)

        # Add axes
        axes = vtk.vtkAxesActor()

        # Render the data
        ren = vtk.vtkRenderer()
        ren.AddActor(actor)
        ren.AddActor(axes)
        ren.SetActiveCamera(camera)

        # Create a render window
        renWin = vtk.vtkRenderWindow()
        renWin.AddRenderer(ren)
        renWin.SetSize(800, 800)

        # Start the visiuilization
        iren = vtk.vtkRenderWindowInteractor()
        iren.SetRenderWindow(renWin)
        ren.SetBackground(0,0,0)
        renWin.Render()


        vtk.vtkPolyDataMapper().SetResolveCoincidentTopologyToPolygonOffset()

        if save_png is True:
            w2if = vtk.vtkWindowToImageFilter()
            w2if.SetInput(renWin)
            w2if.Update()

            writer = vtk.vtkPNGWriter()
            writer.SetFileName(self.files[&#39;png_image&#39;])
            writer.SetInputDataObject(w2if.GetOutput())
            writer.Write()

            print &#39;Wrote mesh image to: &#39; + self.files[&#39;png_image&#39;]

        if interact is True:
            iren.Start()
</div>
<div class="viewcode-block" id="PanelMesh.scale"><a class="viewcode-back" href="../../../module_doc.html#bemio.mesh_utilities.mesh.PanelMesh.scale">[docs]</a>    def scale(self, scale_vect):
        &#39;&#39;&#39;Function used to scale mesh objects in the x, y, and z directions.

        Parameters:
            scale_vect : list
                A list that contains the x, y, and z scale factors for the mesh

        Examples:
            This example assumes that a mesh has been read by bemio and mesh
            data is contained in a `PanelMesh` object called `mesh`

            Here is how to scale a mesh by a factor of 2 in the x direction and
            .5 in the y direction:

            &gt;&gt;&gt; mesh.scale(scale_vect=[2, 0.5, 1])
        &#39;&#39;&#39;
        scale_vect = np.array(scale_vect)
        if scale_vect.size != 3:
            raise Exception(&#39;The scale_vect input must be a length 3 vector&#39;)
        self.points = self.points*scale_vect
        self.scale_vect = scale_vect
        self._create_vtp_mesh()
        print &#39;Scaled mesh by: &#39; + str(scale_vect)
</div>
<div class="viewcode-block" id="PanelMesh.translate"><a class="viewcode-back" href="../../../module_doc.html#bemio.mesh_utilities.mesh.PanelMesh.translate">[docs]</a>    def translate(self,translation_vect,translate_cog=True):
        &#39;&#39;&#39;Function used to translate mesh obvjects in the x, y, and z directions.

        Parameters:
            translation_vect : list
                A list that contains the desired x, y, and z translation for the
                mesh

        Examples:
            This example assumes that a mesh has been read by bemio and mesh
            data is contained in a `PanelMesh` object called `mesh`

            Here is how to translate a mesh by 2 in the x direction and
            .5 in the y direction:

            &gt;&gt;&gt; mesh.translate(scale_vect=[2, 0.5, 0])
        &#39;&#39;&#39;
        translation_vect = np.array(translation_vect)
        if translation_vect.size != 3:
            raise Exception(&#39;The translation_vect input must be a length 3 vector&#39;)
        self.points += translation_vect
        self.translation_vect = translation_vect

        if translate_cog is True:
            self.center_of_gravity += translation_vect

        print &#39;Translated mesh by: &#39; + str(translation_vect) + &#39;\nCenter of gravity is: &#39; + str(self.center_of_gravity)
</div>
<div class="viewcode-block" id="PanelMesh.open"><a class="viewcode-back" href="../../../module_doc.html#bemio.mesh_utilities.mesh.PanelMesh.open">[docs]</a>    def open(self):
        &#39;&#39;&#39;Function to open a VTK PolyData object in the default viewer of your
        operating system.

        .. Note::
            This function is only available for OSX and Linux systems and
            and requires you have a program installed that has the ability to
            open VTK PolyData (.vtp) files.

        Example:
            This example assumes that a mesh has been read by bemio and mesh
            data is contained in a `PanelMesh` object called `mesh`

            &gt;&gt;&gt; mesh.open()
        &#39;&#39;&#39;
        self.write(mesh_format=&#39;VTP&#39;)
        if _system() == &#39;Darwin&#39;:
            os.system(&#39;open &#39; + self.files[&#39;vtp&#39;])

        elif _system() == &#39;Linux&#39;:
            os.system(&#39;xdg &#39; + self.files[&#39;vtp&#39;])

        else:
            raise Exception(&#39;The open function is only supported for OSX&#39;)

</div>
    def _create_vtp_mesh(self):
        &#39;&#39;&#39;Internal function to creat a VTP mesh from the imported mesh data
        &#39;&#39;&#39;
        if self.VTK_installed is True:

            self.vtp_mesh    = vtk.vtkPolyData()
            points  = vtk.vtkPoints()
            polys   = vtk.vtkCellArray()

            for i in range(self.points.shape[0]):

                points.InsertPoint(i, self.points[i])


            for i in range(self.faces.shape[0]):

                polys.InsertNextCell(_mk_vtk_id_list(self.faces[i]))

            self.vtp_mesh.SetPoints(points)
            self.vtp_mesh.SetPolys(polys)

    # def _collapse(self,plane=2,value=0.0,direction=1):
    #This function is not yet working 100%

    #     &#39;&#39;&#39;Collapse points
    #     &#39;&#39;&#39;
    #     for face,face_n in xrange(self.faces.shape[0]):
    #
    #         for j in xrange(self.faces[i].size):
    #
    #             p = int(self.faces[i][j])
    #
    #             if self.points[p][plane] &gt; value*direction:
    #
    #                 self.points[p][plane] = value

    def _write_vtp(self):
        &#39;&#39;&#39;Internal function to write VTK PolyData mesh files
        &#39;&#39;&#39;
        if self.VTK_installed is False:

            raise VTK_Exception(&#39;VTK must be installed write VTP/VTK meshes, please select a different output mesh_format&#39;)

        writer = vtk.vtkXMLPolyDataWriter()
        writer.SetFileName(self.files[&#39;vtp&#39;])
        if vtk.VTK_MAJOR_VERSION &gt;= 6:
            writer.SetInputData(self.vtp_mesh)
        else:
            writer.SetInput(self.vtp_mesh)
        writer.SetDataModeToAscii()
        writer.Write()

        print &#39;Wrote VTK PolyData mesh to: &#39; + str(self.files[&#39;vtp&#39;])

    def _write_nemoh(self):
        &#39;&#39;&#39;Internal function to write NEMOH mesh files
        &#39;&#39;&#39;
        with open(self.files[&#39;nemoh&#39;],&#39;w&#39;) as fid:
            fid.write(&#39;2 0&#39;) # This should not be hard coded
            fid.write(&#39;\n&#39;)
            for i in xrange(self.points.shape[0]):
                fid.write(str(i+1) + &#39; &#39; +str(self.points[i]).replace(&#39;[&#39;,&#39;&#39;).replace(&#39;]&#39;,&#39;&#39;))
                fid.write(&#39;\n&#39;)
            fid.write(&#39;0 0 0 0&#39;)
            fid.write(&#39;\n&#39;)
            for i in xrange(self.faces.shape[0]):
                fid.write(str(self.faces[i]+1).replace(&#39;[&#39;,&#39;&#39;).replace(&#39;]&#39;,&#39;&#39;).replace(&#39;.&#39;,&#39;&#39;))
                fid.write(&#39;\n&#39;)
            fid.write(&#39;0 0 0 0&#39;)

        print &#39;Wrote NEMOH mesh to: &#39; + str(self.files[&#39;nemoh&#39;])


    def _write_gdf(self):
        &#39;&#39;&#39;Internal function to write WAMIT mesh files
        &#39;&#39;&#39;
        with open(self.files[&#39;wamit&#39;],&#39;w&#39;) as fid:
            fid.write(&#39;Mesh file written by meshio.py&#39;)
            fid.write(&#39;\n&#39;)
            fid.write(&#39;1 9.80665       ULEN GRAV&#39;)
            fid.write(&#39;\n&#39;)
            fid.write(&#39;0  0    ISX  ISY&#39;)
            fid.write(&#39;\n&#39;)
            fid.write(str(self.faces.shape[0]))
            fid.write(&#39;\n&#39;)
            for i,face in enumerate(self.faces):
                if np.size(face) is 4: # if the mesh element is a quad
                    for j,pointKey in enumerate(face):
                        fid.write(str(self.points[pointKey]).replace(&#39;,&#39;,&#39;&#39;).replace(&#39;[&#39;,&#39;&#39;).replace(&#39;]&#39;,&#39;&#39;) + &#39;\n&#39;)
                if np.size(face) is 3: # if the mesh element is a tri
                    faceMod = np.append(face,face[-1])
                    for j,pointKey in enumerate(faceMod):
                        fid.write(str(self.points[pointKey]).replace(&#39;,&#39;,&#39;&#39;).replace(&#39;[&#39;,&#39;&#39;).replace(&#39;]&#39;,&#39;&#39;) + &#39;\n&#39;)

        print &#39;Wrote WAMIT mesh to: &#39; + str(self.files[&#39;wamit&#39;])

    def _calc_component_vol(self, ):
        &#39;&#39;&#39;Internal function to calculate mesh volume using the methods
        described in Section 3.1 the WAMIT v7.0 users manual.
        &#39;&#39;&#39;
        self._volume_x = 0.
        self._volume_y = 0.
        self._volume_z = 0.
        volume = 0.

        for face_n in xrange(self.faces.shape[0]):
            volume += self.normals[face_n]*self.centroid[face_n]*self.cell_surface_area[face_n]

        self._volume_x = volume[0]
        self._volume_y = volume[1]
        self._volume_z = volume[2]

        print &#39;Calculated x y and z mesh volumes&#39;
</div>
def _read_gdf(file_name):
    &#39;&#39;&#39;Internal function to read gdf wamit meshes
    &#39;&#39;&#39;

    with open(file_name,&#39;r&#39;) as fid:

        lines = fid.readlines()

    mesh_data = PanelMesh(file_name)
    mesh_data.orig_type = &#39;WAMIT (.gdf)&#39;

    mesh_data.gdfLines = lines
    mesh_data.uLen = int(lines[1].split()[0])
    mesh_data.gravity = float(lines[1].split()[1])
    mesh_data.isx = float(lines[2].split()[0])
    mesh_data.isy = float(lines[2].split()[1])
    mesh_data.num_faces = int(lines[3].split()[0])
    mesh_data.num_points = mesh_data.num_faces * 4
    mesh_data.points = np.array([temp.split() for temp in lines[4:]]).astype(np.float)

    mesh_data.pointsString = [str(temp).replace(&quot;,&quot;      ,&#39;&#39;).replace(&#39;\r&#39;,&#39;&#39;) for temp in lines[4:]] # Output string for Nemoh mesh fil

    for panelNum,i in enumerate(np.arange(4,4+mesh_data.num_points,4)):

        mesh_data.faces.append(np.array([i-4,i-3,i-2,i-1]))

    mesh_data.faces = np.array(mesh_data.faces)

    return mesh_data

def _read_stl(file_name):
    &#39;&#39;&#39;Internal function to read stl mesh files
    &#39;&#39;&#39;

    reader = vtk.vtkSTLReader()
    reader.SetFileName(file_name)
    reader.Update()

    mesh_data = PanelMesh(file_name)
    mesh_data.orig_type = &#39;Stereolithography (.stl)&#39;
    mesh_data.num_faces = int(reader.GetOutput().GetNumberOfCells())
    mesh_data.num_points = mesh_data.num_faces * 3
    for i in range(mesh_data.num_faces):
        n = i*3
        mesh_data.faces.append(np.array([n,n+1,n+2,n+2]))
        mesh_data.points.append(np.array(vtk_to_numpy(reader.GetOutput().GetCell(i).GetPoints().GetData())))
    mesh_data.points = np.array(mesh_data.points).reshape([mesh_data.num_faces*3,3])

    return mesh_data

def _read_vtp(file_name):
    &#39;&#39;&#39;Internal function to read vtp mesh files
    &#39;&#39;&#39;

    reader = vtk.vtkXMLPolyDataReader()
    reader.SetFileName(file_name)
    reader.Update()

    mesh_data = PanelMesh(file_name)
    mesh_data.orig_type = &#39;VTK Polydata (.vtp)&#39;
    readerOut = reader.GetOutput()
    mesh_data.num_faces =    int(readerOut.GetNumberOfCells())
    mesh_data.num_points =   int(readerOut.GetNumberOfPoints())

    for i in xrange(mesh_data.num_points):
        mesh_data.points.append(readerOut.GetPoint(i))
    mesh_data.points = np.array(mesh_data.points)

    for i in xrange(mesh_data.num_faces):
        c = readerOut.GetCell(i)
        numCellPoints = int(c.GetNumberOfPoints())
        idsTemp = []
        for i in xrange(numCellPoints):
            idsTemp.append(int(c.GetPointId(i)))
        mesh_data.faces.append(np.array(idsTemp))
    mesh_data.faces = np.array(mesh_data.faces)


    return mesh_data

def _read_nemoh(file_name):
    &#39;&#39;&#39;Internal function to read nemoh mesh
    &#39;&#39;&#39;

    with open(file_name,&#39;r&#39;) as fid:

        lines = fid.readlines()
    temp = np.array([np.array(str(lines[i]).split()).astype(float) for i in range(1,np.size(lines))])
    count = 0

    mesh_data = PanelMesh(file_name)
    mesh_data.orig_type = &#39;NEMOH (.dat)&#39;

    while temp[count,0] != 0.:

        mesh_data.points.append(temp[count,1:])
        count += 1
    count += 1
    while sum(temp[count,:]) != 0.:

        mesh_data.faces.append(temp[count,:])
        count += 1
    mesh_data.points = np.array(mesh_data.points)
    mesh_data.faces = np.array(mesh_data.faces)-1
    mesh_data.num_points = np.shape(mesh_data.points)[0]
    mesh_data.num_faces = np.shape(mesh_data.faces)[0]

    return mesh_data


<div class="viewcode-block" id="read"><a class="viewcode-back" href="../../../module_doc.html#bemio.mesh_utilities.mesh.read">[docs]</a>def read(file_name):
    &#39;&#39;&#39;Function to read surface mesh files. Currently VTK PolyData (.vtk),
    WAMIT (.gdf), NEMOH (.dat), and Stereolithography (.stl) mesh formats are
    supported

    Parameters:
        file_name : str
            Name of the mesh file

    Returns:
        mesh_data : PanelMesh
            A PanelMesh object that contains the mesh data

    Exmaples:
        This example assumes that a VTK PlolyData mesh named mesh.vtp exists
        in the current working directory

        &gt;&gt;&gt; mesh = read(&#39;mesh.vtp&#39;)

        The mesh can then be converted to another format using the `write`
        function. In this case a wamit mesh is created.

        &gt;&gt;&gt; mesh.write(mesh_format=&#39;WAMIT&#39;)

        If the VTK python bindings are installed the mesh can be viewed using
        the following command:

        &gt;&gt;&gt; mesh.view()

        If you would are using OSX or Linux and have Paraview installed you can
        view the file using the follwing command:

        &gt;&gt;&gt; mesh.open()
    &#39;&#39;&#39;
    print &#39;Reading mesh file: &#39; + str(file_name)

    file_name = os.path.abspath(file_name)
    (f_name,f_ext) = os.path.splitext(file_name)

    if f_ext == &#39;.GDF&#39; or f_ext == &#39;.gdf&#39;:
        mesh_data = _read_gdf(file_name)

    elif f_ext == &#39;.stl&#39;:
        mesh_data = _read_stl(file_name)

    elif f_ext == &#39;.vtp&#39;:
        mesh_data = _read_vtp(file_name)

    elif f_ext == &#39;.dat&#39;:
        mesh_data = _read_nemoh(file_name)

    else:
        raise Exception(f_ext + &#39; is an unsupported file mesh file type&#39;)


    mesh_data.files_base = os.path.splitext(file_name)[0] + &#39;_bemio_output&#39;
    mesh_data.files[&#39;vtp&#39;] = mesh_data.files_base + &#39;.vtp&#39;
    mesh_data.files[&#39;wamit&#39;] = mesh_data.files_base + &#39;.gdf&#39;
    mesh_data.files[&#39;nemoh&#39;] = mesh_data.files_base + &#39;.dat&#39;
    mesh_data.files[&#39;png&#39;] = os.path.splitext(file_name)[0] + &#39;.png&#39;

    if mesh_data.VTK_installed is True:

        mesh_data._create_vtp_mesh()

    print &#39;Successfully read mesh file: &#39; + str(file_name)

    return mesh_data
</div>
def _mk_vtk_id_list(it):
    &#39;&#39;&#39;
    Internal function to make vtk id list object

    Parameters:
        it : list
            List of nodes that define a face
    Returns:
        vil: vtkIdList
            A vtkIdList object
    &#39;&#39;&#39;
    vil = vtk.vtkIdList()
    for i in it:
        vil.InsertNextId(int(i))

    return vil

<div class="viewcode-block" id="collapse_to_plane"><a class="viewcode-back" href="../../../module_doc.html#bemio.mesh_utilities.mesh.collapse_to_plane">[docs]</a>def collapse_to_plane(mesh_obj, plane_ind=2, plane_loc=-1e-5, cut_dir=1.):
    &#39;&#39;&#39;Function to collapse points to a given plane

    .. Note::
        This function is not yet implemented
    &#39;&#39;&#39;
    pass

</div>
<div class="viewcode-block" id="cut_mesh"><a class="viewcode-back" href="../../../module_doc.html#bemio.mesh_utilities.mesh.cut_mesh">[docs]</a>def cut_mesh(mesh_obj, plane_ind=2, plane_loc=-1e-5, cut_dir=1.):
    &#39;&#39;&#39;Function to remove cells on one side of plane

    .. Note::
        This function is still early in the stages of development and needs
        to be improved and made more robust.

    Parameters:
        mesh_obj : PanelMesh
            Mesh object to cut
        plane_ind : int, optional
            Index of plane along which to cut the mesh, 0 == x, 1 == y, 2 == z
        plane_loc : float
            Location of the mesh cut
        cut_dir : int, {1, -1}
            Direction for the mesh cut

    Returns:
        cut_mesh : PanelMesh
            Panel mesh object that has been cut as specified

    Examples:
        None avaiable to data
    &#39;&#39;&#39;
    cut_mesh = copy(mesh_obj)
    tempFaces = []
    cut_mesh.removed_faces = []
    cut_mesh.removed_points = []

    for face_n,face in enumerate(cut_mesh.faces):
        if cut_mesh.points[face[0]][plane_ind] &lt;= plane_loc*cut_dir or \
        cut_mesh.points[face[1]][plane_ind] &lt;= plane_loc*cut_dir or \
        cut_mesh.points[face[2]][plane_ind] &lt;= plane_loc*cut_dir or \
        cut_mesh.points[face[3]][plane_ind] &lt;= plane_loc*cut_dir:

            tempFaces.append(face)

        else:
            cut_mesh.removed_faces.append(face)
            cut_mesh.removed_points.append(cut_mesh.points[face[0]])
            cut_mesh.removed_points.append(cut_mesh.points[face[1]])
            cut_mesh.removed_points.append(cut_mesh.points[face[2]])
            cut_mesh.removed_points.append(cut_mesh.points[face[3]])

    cut_mesh.faces = np.array(tempFaces)
    cut_mesh.removed_faces = np.array(cut_mesh.removed_faces)
    cut_mesh.removed_points = np.array(cut_mesh.removed_points)
    cut_mesh._create_vtp_mesh()

    cut_mesh.files_base = os.path.splitext(cut_mesh.file_name)[0] + &#39;_cut_mesh_bemio_output&#39;

    print &#39;Cut mesh in direction [&#39; + str(plane_ind) + &#39;] in direction [&#39; + str(cut_dir) + &#39;] at the location [&#39; + str(plane_loc) + &#39;]&#39;

    return cut_mesh</div>
</pre></div>

          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2015, National Renewable Energy Laboratory and Sandia National Laboratories.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'v1.0a0',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>